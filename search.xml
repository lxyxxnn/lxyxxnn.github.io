<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 添加分类及标签</title>
    <url>/2019/04/24/My-New-Post/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>hello hexo markdown</title>
    <url>/2016/11/16/headwrite/</url>
    <content><![CDATA[<p>我是短小精悍的文章摘要(๑•̀ㅂ•́) ✧</p>
<span id="more"></span>

<p>紧接着文章摘要的正文内容</p>
<p>啦啦啦啦德玛西亚开着法拉利</p>
]]></content>
      <tags>
        <tag>hello</tag>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/05/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>复习springboot</title>
    <url>/2022/05/06/springboot/</url>
    <content><![CDATA[<h2 id="什么是springboot"><a href="#什么是springboot" class="headerlink" title="什么是springboot"></a>什么是springboot</h2><p> springboot是一个管理整合框架的微服务框架，简化了web开发<br> maven是整合jar包的，springboot是整合框架的</p>
<h2 id="springboot-hello-world"><a href="#springboot-hello-world" class="headerlink" title="springboot hello world"></a>springboot hello world</h2><h3 id="在官网下载包"><a href="#在官网下载包" class="headerlink" title="在官网下载包"></a>在官网下载包</h3><h3 id="在idea中新建spring-initial项目"><a href="#在idea中新建spring-initial项目" class="headerlink" title="在idea中新建spring initial项目"></a>在idea中新建spring initial项目</h3>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>java</tag>
        <tag>框架，接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit视频教程，实战开发</title>
    <url>/2020/11/01/test1tags/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Retrofit</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>retrofit</tag>
        <tag>retrofit视频教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/05/hello-world2/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>abc</title>
    <url>/2022/05/06/abc/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>面试题1</title>
    <url>/2022/05/12/mianshi/</url>
    <content><![CDATA[<h2 id="内容1"><a href="#内容1" class="headerlink" title="内容1"></a>内容1</h2><p>阿西吧</p>
<h3 id="三级小标题"><a href="#三级小标题" class="headerlink" title="三级小标题"></a>三级小标题</h3><h2 id="内容2"><a href="#内容2" class="headerlink" title="内容2"></a>内容2</h2><p>阿西吧</p>
<h3 id="三级小标题-1"><a href="#三级小标题-1" class="headerlink" title="三级小标题"></a>三级小标题</h3><h3 id="三级小标题-2"><a href="#三级小标题-2" class="headerlink" title="三级小标题"></a>三级小标题</h3><p>外部链接: <a href="https://www.baidu.com/">链接代名词</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>数组相关面试题</title>
    <url>/2022/05/13/%E6%95%B0%E7%BB%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="js数组API与面试题"><a href="#js数组API与面试题" class="headerlink" title="js数组API与面试题"></a>js数组API与面试题</h1><hr>
<h2 id="javascript数组API"><a href="#javascript数组API" class="headerlink" title="javascript数组API"></a>javascript数组API</h2><hr>
<h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h3><blockquote>
<p><strong>Array()构造器</strong><br>  Array() &#x2F;&#x2F;[]  空数组<br>  Array(3) &#x2F;&#x2F;[,,,]   三个元素的空数组<br>  Array(1,2,3) &#x2F;&#x2F;[1,2,3]<br><strong>Array.of</strong>  用于将一组值，转换为数组，弥补Array方法参数不同造成的差异性<br>  Array.of(1,2,3)<br>  Array.of(1) &#x2F;&#x2F;[1]<br>  Array.of(1).length &#x2F;&#x2F; 1  </p>
</blockquote>
<h3 id="数组静态方法"><a href="#数组静态方法" class="headerlink" title="数组静态方法"></a>数组静态方法</h3><blockquote>
<p><strong>Array.from</strong> 从类数组对象或者-可迭代对象中-创建一个新的数组实例<br>  Array.from(‘foo’) &#x2F;&#x2F;[‘f’,’o’,’o’]<br><strong>Array.isArray()</strong>  判断某个变量是否是一个数组对象<br>  Array.isArray([1,2,3]) &#x2F;&#x2F;true  </p>
</blockquote>
<blockquote>
<p><strong>Array.of</strong>  根据一组参数来创建新的数组实例，支持任意的参数数量和类型<br>  Array.of(7) &#x2F;&#x2F;[7]<br>  Array.of(1,2,3) &#x2F;&#x2F;[1,2,3]</p>
</blockquote>
<h3 id="数组循环执行效率"><a href="#数组循环执行效率" class="headerlink" title="数组循环执行效率"></a>数组循环执行效率</h3><blockquote>
<p>for&gt;forEach&gt;while&gt;map&gt;for…of&gt;for..in<br>   const data &#x3D; new Array(10000000).fill(0);<br>   for(let i &#x3D; 0;i &lt; data.length; i++){}<br>   for(let item of data) {}<br>   for(let key in data) {data[key];}<br>   data.forEach((item)&#x3D;&gt;{item;})<br>   data.map((item)&#x3D;&gt;{<br>    item<br>   })<br>   while(data.length&gt;count) {}</p>
</blockquote>
<h3 id="数组的遍历方法"><a href="#数组的遍历方法" class="headerlink" title="数组的遍历方法"></a>数组的遍历方法</h3><hr>
<p>  <strong>every</strong> 用来测试某个数组中所有元素是否都能通过一个函数的测试<br>  返回值：Boolean  </p>
<p> <strong>some</strong>  </p>
<blockquote>
<p><strong>返回Boolean值</strong>测试函数中至少有一个通过测试就返回true,都没有返回false，<br> 用一个空数组测试返回false</p>
</blockquote>
<p> <strong>filter</strong>  </p>
<blockquote>
<p> <strong>创建一个新数组</strong>，包含通过提供函数测试的所有元素，若没有一个通过<br>测试，返回空数组 </p>
</blockquote>
<p> <strong>forEach</strong>   </p>
<blockquote>
<p><strong>按升序</strong>为数组中含有效值的每一项执行一次callback函数，<br>  已删除的和未初始化的返回undefined  </p>
</blockquote>
<p> <strong>map</strong> </p>
<blockquote>
<p><strong>创建一个新数组</strong>其结果为调用一次提供的函数后的返回值  </p>
</blockquote>
<p> <strong>reduce</strong>  </p>
<blockquote>
<p>对数组每个元素执行一个函数，将其结果汇总会单个返回值  </p>
</blockquote>
<ul>
<li>callback：</li>
</ul>
<p> <strong>reduceRight</strong>   </p>
<blockquote>
<p>接收一个函数作为<strong>累加器</strong>和数组的<strong>每个值（从右到左）</strong>将其<br> 减少位单个值  </p>
</blockquote>
<h3 id="数组的查找"><a href="#数组的查找" class="headerlink" title="数组的查找"></a>数组的查找</h3><p> <strong>find（）</strong>  </p>
<blockquote>
<p>返回数组中满足车市函数中的<strong>第一个元素的值</strong>，否则返回undefined  </p>
</blockquote>
<p> <strong>findIndex()</strong>  </p>
<blockquote>
<p>返回数组中满足测试的<strong>第一个元素的*索引</strong>，没有返回-1  </p>
</blockquote>
<hr>
<h3 id="会修改原始数组的操作"><a href="#会修改原始数组的操作" class="headerlink" title="会修改原始数组的操作"></a>会修改原始数组的操作</h3><p> <strong>fill()</strong>  </p>
<blockquote>
<p>用一个固定值填充从起始索引到终止索引内全部元素，并返回修改后数组<br> <em>语法</em>  arr.fill(value,start,end)<br> eg:[].fill.call({lengh:3},4) &#x2F;&#x2F;{0:4,1:4,2:4,length:3}  </p>
</blockquote>
<p> <strong>1.push()</strong>  </p>
<blockquote>
<p>将一个或多个元素添加到数组末尾<br> <strong>返回值</strong>：数组新长度</p>
</blockquote>
<p> <strong>2.pop()</strong>  </p>
<blockquote>
<p>从数组中删除最后最后一个元素<br>   <strong>返回值</strong>：删除了的元素的值<br>   会更改数组长度<br>   数组为空时返回undefined</p>
</blockquote>
<p> <strong>3.reverse()</strong>  </p>
<blockquote>
<p>将数组元素位置颠倒<br>  <strong>返回值</strong>:颠倒后的数组  </p>
</blockquote>
<p> <strong>4.shift()</strong>  </p>
<blockquote>
<p>从数组中删除第一个元素<br>    <strong>返回值</strong>：删除了的元素的值 </p>
</blockquote>
<p> <strong>5.unshift()</strong>  </p>
<blockquote>
<p>将一个或多个元素添加到数组的开头<br> <strong>返回值</strong>:数组的新长度</p>
</blockquote>
<p> <strong>6.splice(start,deletecount,[item1,item2…])</strong>  </p>
<blockquote>
<p>通过  <em>删除</em> 或 <em>替换</em>现有的元素或者<em>原地添加新的元素</em>来修改数组<br>  <strong>返回值</strong>：以数组形式返回被修改的内容（被删除的内容）<br>  如果没有删除元素返回空数组，如果删除一个返回一个元素的数组  </p>
</blockquote>
<ul>
<li>start:大于数组长度时从数组末尾添加，负值代表从后往前数低级个开始，负数绝对值大于<br>  数组长度则从0位开始   </li>
<li>deleteCount：大于数组长度代表全部删除，为0或者负数代表不删除，但至少添加一个新元素  </li>
<li>item1，item2…代表添加的元,不指定代表只删除</li>
</ul>
<p> <strong>7.sort()</strong><br> 将元素转换为字符串,比较UTF-16代码 单元之序列<br> 参数指定一个方法a&gt;b从小打到 b&gt;a从大到小  </p>
<h3 id="不修改原始数组的操作"><a href="#不修改原始数组的操作" class="headerlink" title="不修改原始数组的操作"></a>不修改原始数组的操作</h3><p><strong>concat(vlue1…vlueN)</strong>  </p>
<blockquote>
<p><em>合并两个或多个数组，不更改现有数组，返回一个新数组</em><br><strong>参数</strong>：valueN省略则实现现存数组的ige浅拷贝  </p>
</blockquote>
<p><strong>join(separator)</strong>  </p>
<blockquote>
<p>将一个数组（类数组也可以）的所有元素连接成一个字符串并返回<br> separator:分隔符，省略默认使用,分割<br><strong>slice(begin，end)</strong><br><strong>浅拷贝</strong> 返回一个新的数组对象，由begin和end决定，原数组不被改变</p>
</blockquote>
<p>**toString()**：返回指定数组及其元素的字符串  </p>
<h3 id="数组的扁平化-1-2-3-4-5-6-x3D-gt-1-2-3-4-5-6"><a href="#数组的扁平化-1-2-3-4-5-6-x3D-gt-1-2-3-4-5-6" class="headerlink" title="数组的扁平化([1,[2,3],[4,[5,6]]]&#x3D;&gt;[1,2,3,4,5,6])"></a>数组的扁平化([1,[2,3],[4,[5,6]]]&#x3D;&gt;[1,2,3,4,5,6])</h3><p><strong>flat</strong>：arr.flat(infinity)  </p>
<p><strong>遍历,递归方法</strong><br>function flatten(arr) {<br>  return arr.reduce((pre,current)&#x3D;&gt;{<br>   pre.concat(Array.isArray(current)? flatten(current) : current)<br>  },[])<br>}  </p>
<p><em>使用forEach遍历</em><br>function flatten(arr) {<br>let result &#x3D; []<br>arr.forEach(item&#x3D;&gt;{<br> if(Array.isArray(item)){<br>       result &#x3D; result.concat(flatten(item))<br> } else {<br>     result.push(item)</p>
<p> })</p>
<p>})<br>}</p>
<p>** 使用toString和split**<br> return arr.toString().split(‘,’).map&#x3D;&gt;{item&#x3D;&gt;Number(item)}</p>
<p><strong>使用join和split</strong><br> return arr.join(‘,’).split(‘,’).map(item&#x3D;&gt;Number(item))</p>
<h3 id="数组元素中对象属性去重"><a href="#数组元素中对象属性去重" class="headerlink" title="数组元素中对象属性去重"></a>数组元素中对象属性去重</h3><p>let arr &#x3D; [<br> {“age”:13,name:”sss”},<br> {“age”:14,name:”aaa”},<br> {“age”:15,name:”ddd”},<br> {“age”:16,name:”sss”},<br>]   </p>
<p>function removeRepeat(arr) {<br> let result &#x3D; [],obj &#x3D; {}<br> arr.forEach(item&#x3D;&gt; {<br>  if(!obj[item.name]) {<br>    result.push(item)<br>    obj[item.name] &#x3D; true<br>  }<br> })<br>  return result<br>}</p>
<h3 id="复制数组-深拷贝"><a href="#复制数组-深拷贝" class="headerlink" title="复制数组(深拷贝)"></a>复制数组(深拷贝)</h3><blockquote>
<p><strong>深拷贝</strong>：创建一个新的对象和数组，将原本对象的各项<strong>属性的值</strong>拷贝过来<br>是值 而不是 引用，新对象和原独享不共享内存<br>修改新对象不会影响原都西昂<br><strong>浅拷贝：</strong>原对象原数组的引用直接赋给新对象，是同一个引用  </p>
</blockquote>
<blockquote>
<p>扩展运算符实现<br>let arr1 &#x3D; […arr]<br>arr1[0] &#x3D; true  </p>
</blockquote>
<blockquote>
<p>循环实现<br>function deepClone(val) {<br>  if(val &#x3D;&#x3D;&#x3D; “object” &amp;&amp; val !&#x3D;&#x3D;null)  {<br>    let result &#x3D; Array.isArray(val)? [] : {}<br>    for(let key in val) {<br>     result[key] &#x3D; deepClone(val[key])<br>    }<br>    return result<br>  }<br>  return val<br>}</p>
</blockquote>
<h3 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h3><h4 id="使用filter和includes"><a href="#使用filter和includes" class="headerlink" title="使用filter和includes"></a>使用filter和includes</h4><p>  arr1 &#x3D; [1,2,3,4,4,5]<br>  arr2 &#x3D; [4,5]<br>  new […set(arr1)].filter((item)&#x3D;&gt;arr2.includes(item))<br>  &#x2F;&#x2F;用扩展表达式和set将arr1先去重再变回数组  </p>
<h3 id="数组元素是对象的时候各种操作"><a href="#数组元素是对象的时候各种操作" class="headerlink" title="数组元素是对象的时候各种操作"></a>数组元素是对象的时候各种操作</h3><blockquote>
<p> <strong>交集</strong><br>  arr1.filter(item&#x3D;&gt; arr2.some(item2 &#x3D;&gt; item2.id &#x3D;&#x3D;&#x3D; item.id)<br>** 差集**<br>  arr1.filter(item&#x3D;&gt; arr2.every(item2 &#x3D;&gt; tem2.id!&#x3D;&#x3D;item.id))<br>交集<br>  let newArray &#x3D; […arr1,…arr2]<br>  newArray.forEach(item&#x3D;&gt;{<br>   if(!obj[item.id]) {<br>      result.push(item)<br>      obj[item.id] &#x3D; true<br>    }<br>  })</p>
</blockquote>
<p>  obj &#x3D; null<br>  return result<br>}</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>js面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题第一天</title>
    <url>/2022/05/12/%E7%AC%AC%E4%B8%80%E5%A4%A9%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一、将数组的length设置为0，取第一个元素会返回什么？"><a href="#一、将数组的length设置为0，取第一个元素会返回什么？" class="headerlink" title="一、将数组的length设置为0，取第一个元素会返回什么？"></a>一、将数组的length设置为0，取第一个元素会返回什么？</h2><blockquote>
<p>设置 length &#x3D; 0 会清空数组，所以会返回 undefined</p>
</blockquote>
<h2 id="二、css动画和js动画分别有哪些优缺点"><a href="#二、css动画和js动画分别有哪些优缺点" class="headerlink" title="二、css动画和js动画分别有哪些优缺点"></a>二、css动画和js动画分别有哪些优缺点</h2><h3 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote>
<p>浏览器可以对动画进行优化<br>代码相对简单，<strong>性能调优方向固定</strong><br>对于帧速表现不好的低版本浏览器，css可以做到自然降级，<br>   而JS则需要撰写额外代码</p>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<p>运行过程比较弱，无法符加事件绑定回调函数<br>代码冗长，用css实现稍微复杂一点的动画css代码都会变得很笨重</p>
</blockquote>
<h3 id="js动画"><a href="#js动画" class="headerlink" title="js动画"></a>js动画</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><blockquote>
<p>控制能力很强，可以在动画播放过程中对动画进行控制：开始，暂停，回放，终止<br>   取消都是可以做到的。<br>动画效果比css3动画丰富，比如曲线运动，冲击闪烁，视差滚动效果，<strong>只有js动画才能完成</strong><br>css3有兼容性问题，而js大多时候没有兼容性问题</p>
</blockquote>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<p>代码的复杂度高于css动画<br>js代码在浏览器主线程中运行，但主线程中还有其他需要运行的js脚本，样式计算，布局<br>   绘制任务等，对其干扰会导致线程出现阻塞，造成丢帧的情况</p>
</blockquote>
<hr>
<h2 id="三、前端实现动画有哪些方式"><a href="#三、前端实现动画有哪些方式" class="headerlink" title="三、前端实现动画有哪些方式"></a>三、前端实现动画有哪些方式</h2><h3 id="最常用的动画实现方式有以下几种"><a href="#最常用的动画实现方式有以下几种" class="headerlink" title="最常用的动画实现方式有以下几种"></a>最常用的动画实现方式有以下几种</h3><blockquote>
<p>1.css3的transition属性<br>  用来设置样式的属性值是如何从一种平滑的状态过渡到另一个状态<br>  transition可以拆为四个过度属性：  </p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>规定设置过渡效果的css属性的名称</td>
</tr>
<tr>
<td>transition-duration</td>
<td>规定完成过渡效果需要多少秒或毫秒</td>
</tr>
<tr>
<td>transition-timing-fuction</td>
<td>规定速度效果的速度曲线</td>
</tr>
<tr>
<td>transition——delay</td>
<td>定义过渡效果何时开始</td>
</tr>
<tr>
<td><strong>演示代码</strong></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">width:50px;</span><br><span class="line">height:50px;</span><br><span class="line">background-color:pink;</span><br><span class="line">transition:1s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">div:hover&#123;</span><br><span class="line">width:200px;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td><strong>transition默认属性为</strong>：transition：all 0 ease 0；</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<hr>
<blockquote>
<p>2.css3的animation属性<br>  animation属性类似于flash逐帧动画，由关键帧组成，由keyframes属性完成<br>  ** animation与transition的区别：<br>  transition只需要指定动画开始和结束的状态，整个动画的过程是由整个特定的函数控制，不需要管<br>  animation可以对动画过程中各个关键帧进行设置<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">widht:300px;</span><br><span class="line">height:300px;</span><br><span class="line">background-color:pink;</span><br><span class="line">&#125;</span><br><span class="line">div:hover&#123;</span><br><span class="line">animation:change1 5s;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes change1&#123;</span><br><span class="line">25% &#123;widht:130px;background-color:red;&#125;</span><br><span class="line">50% &#123;widht:140px;background-color:blue;&#125;</span><br><span class="line">75% &#123;widht:210px;background-color:green;&#125;</span><br><span class="line">100% &#123;width:250px;background-color:yellow;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.原生js动画<br>   **主要思想是通过setInterval和setTimeout方法的回调函数来持续<br>   调用改变某个元素的css样式以达到元素样式变化的效果。<br>   <strong>问题：</strong>js实现动画会导致页面频繁重排重绘，一般用在pc上，移动端会明显卡顿</p>
</blockquote>
<pre><code> &lt;script&gt;
 let elem = document.querySelector(&quot;#rect&quot;);
 let left = 0;
 let timer = setInterval(function() &#123;
  if(left&lt;window.innerWidth-200) &#123;
  elem.style.marginLeft = left +&#39;px&#39;;
  left++;
  &#125; else &#123;
   clearInterval(timer);
  &#125;
 &#125;,16)
 &lt;/script&gt;
</code></pre>
<p>   在很多移动端动画性能优化时，一般使用16ms来进行<strong>节流处理</strong>连续触发的浏览器事件<br>   通过这种方式减少持续事件的触发频率，提高动画流畅性</p>
<blockquote>
<p>4.使用canvas绘制动画<br>5.SVG动画<br>6.jquery的animate函数<br>7,使用gif图片</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>代码复杂度方面简单动画：css代码实现会简单一些，js复杂一些。 复杂动画的话：css代码就会变得冗长，js实现起来更优。</li>
</ul>
</blockquote>
<ul>
<li>动画运行时，对动画的控制程度上 js 比较灵活，能控制动画暂停，取消，终止等css动画不能添加事件，只能设置固定节点进行什么样的过渡动画。</li>
<li>兼容方面 css 有浏览器兼容问题js大多情况下是没有的。</li>
<li>性能方面 css动画相对于优一些，css 动画通过GUI解析js动画需要经过js引擎代码解析，然后再进行 GUI 解析渲染。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相关面试题</title>
    <url>/2022/05/13/%E7%AC%AC%E4%BA%8C%E9%A2%98%E9%82%A3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="第0题，字符串的api"><a href="#第0题，字符串的api" class="headerlink" title="第0题，字符串的api"></a>第0题，字符串的api</h2><blockquote>
<ul>
<li>**charAt() &#x3D;&#x3D;返回指定位置的字符&#x3D;&#x3D;<br>var str &#x3D; “abc”<br>str.charAt(2) &#x2F;&#x2F;c</li>
</ul>
</blockquote>
<ul>
<li>**chartCodeAt() &#x3D;&#x3D;返回在指定位置的字符Unicode编码<br>  str.chartCodeAt(1) &#x2F;&#x2F;98  </li>
<li>**concat() &#x3D;&#x3D; 连接字符串<br>  var a&#x3D;”lxy”,b&#x3D;”csy”;<br>  var c &#x3D; a.concat(b);  &#x2F;&#x2F;lxycsy  </li>
<li>**indexOf() &#x3D;&#x3D;检索字符串&#x3D;&#x3D;<br>  var str &#x3D; “hello myfriend”<br>  str.indexOf(“Hello”) &#x2F;&#x2F;0<br>  str indexOf(“world”) &#x2F;&#x2F;-6<br>  **区分大小写  </li>
<li><strong>match()  &#x3D;&#x3D;在字符串内检索指定的值，或找到 正则表达式匹配的字符串，返回指定的值<br>  var str &#x3D;”1 abc 2 def 3”;<br>  str.match(&#x2F;\d+&#x2F;g) &#x2F;&#x2F;123  &#x2F;&#x2F;</strong>&#x2F;\d+&#x2F;g全局匹配数字一个或多个  </li>
<li>**replace()  &#x3D;&#x3D; 用你指定的字符串替换str中的字符串，首先要用正则<br>找到然后替换&#x3D;&#x3D;<br>var str &#x3D; “xinnian shandi”<br>str.replace(&#x2F;xinnian&#x2F;,”xingyu”) &#x2F;&#x2F;xingyu shandi  </li>
<li>**search() 用于检索字符串中指定子字符串，或检索与正则表达式相匹配的字符串，<br>**若忽略大小写追加标志i，没找到返回&#x3D;&#x3D;-1&#x3D;&#x3D;<br>var str &#x3D; “abc DEF”<br>str.search(&#x2F;DEF&#x2F;i) &#x2F;&#x2F;4  </li>
<li>**slice(start,end) &#x3D;&#x3D;提出字符串的”片段“，在新的字符串中返回被提取部分<br>未指定start：  <ul>
<li>负数：从字符串尾部开始计算起始位置，-1代表最后一个字符  </li>
<li>-2“倒数第二个字符<br>未指定end：  </li>
<li>负数： 从尾部开始计算  </li>
<li>未指定：从start到字符串结尾length-1<br>var str&#x3D;”abc def ghk”<br>console.log(str.slice(6))&#x2F;&#x2F;f ghk</li>
</ul>
<p>	</p>
</li>
<li>** split()把字符串分割为字符串数组  参数位分隔符，从字符串中判断用什么作为分隔符<br>var str&#x3D;”lxy csy lyn yqn wmt“;<br>str.split(“”); &#x2F;&#x2F; [‘l’,’x’,’y’,’ ‘,’c’….,’t’]<br>str.split(“ “); &#x2F;&#x2F; [‘lxy’,’csy’…]<br>str.split(“ “,3)  &#x2F;&#x2F;分割的数组长度3  </li>
<li>**toLocaleUpperCase()和toLowerCase()<br>  var str &#x3D; “LXY MAKE you”<br>  str.toLocaleUpperCase() &#x2F;&#x2F;LXY MAKE YOU  </li>
<li>**sbustr(起始位置，截取数量)  从起始位置提取字符串中指定数目字符<br>  substr(start,length)<br>  start:</li>
</ul>
<ul>
<li>要抽取子串的其实下表，负数代表从尾部开始提取<br>  length：可选，子串中的字符数（位数）。省略则代表从开始到结尾    <figure class="highlight plaintext"><figcaption><span>str</span></figcaption><table><tr><td class="code"><pre><span class="line">  console.log(str.substr(2))//c def</span><br><span class="line">  console.log(str.substr(2,4))// c de```</span><br><span class="line">  </span><br><span class="line">  + **subString(起始位置，截取结束点)  </span><br><span class="line">  str.subString(1,3) //&quot;bc &quot;  </span><br><span class="line">  ### Es6新增操作字符串的方法  </span><br><span class="line">  *******************  </span><br><span class="line">  &gt; ### codePointAt()  </span><br><span class="line">  let s=&#x27;李xy&#x27;  </span><br><span class="line">  s.codePointAt(0)  //李前2个字节的十进制码点  </span><br><span class="line">  s.codePointAt(1)  //李后俩个字节十进制码点  </span><br><span class="line">  s.codePointAt(2)  //字符a的ascii码  </span><br><span class="line">  ### String.fromCodePOint()  用于返回字符串从码点开始</span><br><span class="line">  es5提供String.fromCharCode方法，从码点**返回对应字符**  </span><br><span class="line">  资格方法不识别32位的 UTF-16字符</span><br><span class="line">  **String.fromCharCode不能识别大于0xFFFF的码点，0x20BB7&gt;0xFFFF最高位2被舍弃  </span><br><span class="line">  **最后返回了码点U+0BB7的字符，就是个乱码，而ES6的S他string.fromCodePoint方  </span><br><span class="line">  ** 法可以是识别大于0xFFFF的字符，弥补了fromCharCode的不足  </span><br><span class="line">  String.fromCodePoint(0x20BB7) //李  </span><br><span class="line">  ### 字符串遍历接口 for of  </span><br><span class="line">  for(let str of &#x27;abc&#x27;) &#123;  </span><br><span class="line">   console.log(str);   </span><br><span class="line">  &#125;  </span><br><span class="line">  //&quot;a&quot;  </span><br><span class="line">  //&quot;b&quot;  </span><br><span class="line">  //&quot;c&quot;  </span><br><span class="line">  可以识别Unicode编号大于0XFFFF的字符  </span><br><span class="line">  ### at() 可以识别Unicode编号大于0xFFFF的字符，返回正确字符  </span><br><span class="line">  ’abc‘.at(0) //&#x27;a&#x27;  </span><br><span class="line">  &#x27;吉&#x27;.at(0) //“吉”  </span><br><span class="line">  ### Unicode正规化  </span><br><span class="line">  采用normalize()方法 将字符*不同*的表示方法统一为同样的样式   </span><br><span class="line">    许多欧洲语言有语调符号和重音符号，为了表示它们，Unicode 提供了两种方法。一种是  </span><br><span class="line">	直接提供带重音符号的字符，比如Ǒ（u01D1）  </span><br><span class="line">	另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，  </span><br><span class="line">	比如O（u004F）和ˇ（u030C）合成Ǒ（u004Fu030C）。  </span><br><span class="line">	**’\u01D1‘ === ’\u004F\u030C‘ false</span><br><span class="line">	**&#x27;\u01D1&#x27;.normalize() === &#x27;\u004F\u030C&#x27;.normalize() true  </span><br><span class="line">  ### includes(),startWith(),endsWith()  </span><br><span class="line">  对比之前只有indexOf可以用来确定一个字符串是否包含在另一个字符串中   </span><br><span class="line">  **以上这三种方法都支持第二个参数，表示开始搜索的位置，返回类型位Boolean  </span><br><span class="line">  </span><br><span class="line">  let s = &#x27;Hello world!&#x27;; </span><br><span class="line">  s.startsWith(&#x27;Hello&#x27;) // true</span><br><span class="line">  s.startsWith(&#x27;world&#x27;, 6) // true</span><br><span class="line">  s.includes(&#x27;Hello&#x27;, 6) // false</span><br><span class="line">  </span><br><span class="line">  **其中endWidth第二个参数代表前n个字符，其他两个方法针对从第n个位置知道字符串结束  </span><br><span class="line">  ### repeat(n),返回一个新的字符串，重复了n次的原字符串    </span><br><span class="line">  n:  </span><br><span class="line">  - 3:重复三次  </span><br><span class="line">  - 2.9 取整，重复2次  </span><br><span class="line">  - 负数或infinity ：报错RangeError  </span><br><span class="line">  </span><br><span class="line">  ### padStart(a,b)，padEnd()  </span><br><span class="line">  a:不全的长度 b：填充的字符  </span><br><span class="line">  - padStart(5,ab) :在目标字符串前补充ab到够5位</span><br><span class="line">  - padEnd(5,ab) :在目标字符串后补充ab到够5位</span><br><span class="line">  - 原字符串长度大于a或等于a的长度，返回原字符串  </span><br><span class="line">  - 省略第二个参数，使用空格补全</span><br><span class="line">  **最常见的用途是位数值补全指定位数  </span><br><span class="line">  **另一种用途是提示字符串格式  </span><br><span class="line">  &#x27;12&#x27;.padStart(10,&#x27;YYYY-MM-DD&#x27;)  </span><br><span class="line">  </span><br><span class="line">  &#x27;09-12&#x27;.padStart(10, &#x27;YYYY-MM-DD&#x27;) // &quot;YYYY-09-12&quot; </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ### matchAll()  </span><br><span class="line">  返回一个遍历器，其中包含了所有匹配正则表达式和分组捕获结果  </span><br><span class="line">  **应为返回的是遍历器** 所以使用for of    </span><br><span class="line">  for(const math of &#x27;lxyacnl&#x27;.matchAll(/l/g)) &#123;  </span><br><span class="line">    console.log(match)</span><br><span class="line">  &#125;  </span><br><span class="line">  // [&quot;l&quot;,index:0],[&quot;l&quot;,index:7]  </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  ### 字符串模板  </span><br><span class="line">  - 可以调用函数 </span><br><span class="line">  - $&#123;’字符串‘&#125; 原样输出  </span><br><span class="line">  - 可以嵌套 </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 第一题，字符串相加</span><br><span class="line">&gt; **给定两个字符串形式的负整数num1，计算它们的和并同样以字符串形式返回。  </span><br><span class="line">  **示例**  </span><br><span class="line">  输入：num1 = “11”，num2 = “123” 输出：“134”</span><br><span class="line">  *思路*：定义两个指针i，j分别指向num1，num2末尾，最低位，同时定义  </span><br><span class="line">  **一个变量add**维护当前是否有进位，然后从末尾到开头逐位相加即可。  </span><br></pre></td></tr></table></figure>
var addStrings &#x3D; function(num1,num2) {<br>let i &#x3D; num1.length - 1,j&#x3D;num2.length-1,add &#x3D; 0;<br>const ans &#x3D; [];<br>while(i&gt;&#x3D;0||j&gt;&#x3D;0||add!&#x3D;0) {<br> const x &#x3D; i&gt;&#x3D;0? num1.chartAt(i) - ‘0’ : 0;<br> const y &#x3D; j&gt;&#x3D;0? num2.chartAt(j) - ‘0’ : 0;<br> const result &#x3D; x+y+add;<br> ans.push(result%10);<br> add &#x3D; Math.floot(result &#x2F; 10);<br> i -&#x3D; 1;<br> j -&#x3D; 1;<br>}<br> return ans.reverse().join(‘’);<br>}<br>  &#96;&#96;&#96;<br> **复杂度分析<ul>
<li>事件复杂度：O（max（len1，len2））</li>
<li>空间复杂度：O（1）我们只需要常数空间存放若干变量const</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第二题，写一个repeat方法，实现字符串复制拼接"><a href="#第二题，写一个repeat方法，实现字符串复制拼接" class="headerlink" title="第二题，写一个repeat方法，实现字符串复制拼接"></a>第二题，写一个repeat方法，实现字符串复制拼接</h2><blockquote>
<h3 id="方法1：空数组join"><a href="#方法1：空数组join" class="headerlink" title="方法1：空数组join"></a>方法1：空数组join</h3><p>  function repeat(target,n) {<br>   return (new Array(n+1).join(target))<br>  }</p>
</blockquote>
<h3 id="方法2：无需创建数组，提高性能"><a href="#方法2：无需创建数组，提高性能" class="headerlink" title="方法2：无需创建数组，提高性能"></a>方法2：无需创建数组，提高性能</h3><p>  function repeat(target,n) {<br>  return  Array.prototype.join.call({length:n+1},target)<br>  }</p>
<h3 id="方法3：利用闭包缓存join，避免重复创建对象，寻找方法"><a href="#方法3：利用闭包缓存join，避免重复创建对象，寻找方法" class="headerlink" title="方法3：利用闭包缓存join，避免重复创建对象，寻找方法"></a>方法3：利用闭包缓存join，避免重复创建对象，寻找方法</h3><p>  var repeat &#x3D; (function() {<br>   var join &#x3D; Array.prototype.join,obj &#x3D; {};<br>   return function(target,n) {<br>     obj.length &#x3D; n+1;<br>     return join.call(obj.target);<br>   };<br>  })  </p>
<h3 id="使用二分法"><a href="#使用二分法" class="headerlink" title="使用二分法"></a>使用二分法</h3><p>  function repeat(target,n){<br>   var s &#x3D; target,total&#x3D;[];<br>   while(n&gt;0) {<br>    if(n%2 &#x3D;&#x3D;&#x3D; 1) {<br>     total[total.length] &#x3D; s;<br>    }<br>    if(n &#x3D;&#x3D;&#x3D;1 ) {<br>     break;<br>    }<br>    s+&#x3D;s;<br>    n &#x3D; n &gt;&gt; 1;  	<br>   }<br>   return total.join(‘’);<br>  }
  </p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>js面试题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Object相关api与类型转换</title>
    <url>/2022/05/15/%E5%AF%B9%E8%B1%A1%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Object-Api"><a href="#Object-Api" class="headerlink" title="Object Api"></a>Object Api</h2><hr>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><blockquote>
<ul>
<li>object.prototype<br>  返回原型对象</li>
</ul>
</blockquote>
<ul>
<li><p>object.key(obj)<br> 遍历对象的可枚举属性  </p>
</li>
<li><p>object.getOwnPropertyName(obj)<br>  遍历对象不可枚举的属性  </p>
</li>
<li><p>valueOf<br>   返回当前对象对应的值  </p>
</li>
<li><p>toString<br>   返回当前对象对应的字符串形式     </p>
</li>
<li><p>hasOwnProperty<br>  判断某个属性是否为当前对象的属性，还是继承于原型对象的属性  </p>
</li>
<li><p>toLocaleString<br>  返回当前对象对应的 本地字符串形式  </p>
</li>
<li><p>isPrototypeOf<br>  判断当前对象是否为另一个对象的原型  </p>
</li>
<li><p>propertyIsEnumerable<br>  判断某个属性是否可枚举</p>
</li>
</ul>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><blockquote>
<ul>
<li>Number.POSITIVE_INFINITY &#x2F;&#x2F;正无限</li>
</ul>
</blockquote>
<ul>
<li>Number.NEGATIVE_INFINITY &#x2F;&#x2F;负无限  </li>
<li>Number.NaN &#x2F;&#x2F;非数值  </li>
<li>Number.MAX_VALUE &#x2F;&#x2F;表示最大的正数  </li>
<li>Number.MIN_VALUE &#x2F;&#x2F;表示最想的正数  最接近0的正数  </li>
<li>Number。MAX_SAFE_INTEGER  &#x2F;&#x2F;9007199254740991。</li>
</ul>
<hr>
<p>**实例方法  </p>
<blockquote>
<ul>
<li>toString()  接收一个参数 表示输出的进制  <ul>
<li>toFixed()  将一个数转换为指定位数的小数，返回字符串</li>
<li>toExponential()  将一个数转为科学计数法形式，参数：小数点后有效数字位数</li>
<li>toPrecision()  用于将一个数字转换为指定位数的有效数字</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><hr>
<p>** 属性  </p>
<blockquote>
<ul>
<li>Math.E   常数E</li>
</ul>
</blockquote>
<ul>
<li>Math.LN2  2的自然对数</li>
<li>Math.LN10   10的自然对数</li>
<li>Math.LOG2E   以2为底的e的对数  </li>
<li>Math.LOG10E    以10为底E的对数  </li>
<li>Math.PI   </li>
<li>Math.SQRT1_2  0.5的平方根</li>
<li>Math.SQRT2   2的平方根</li>
</ul>
<hr>
<p>** 方法  </p>
<blockquote>
<ul>
<li>Math.abs()  返回绝对值</li>
</ul>
</blockquote>
<ul>
<li>Math.ceil() 向上取整，返回一个大于参数的最小整数  </li>
<li>Math.floor() 向下取整  </li>
<li>Math.max(1,2,3…)  </li>
<li>Math.pow(n,e)  n底数,e幂  </li>
<li>Math.sqrt() 返回一个数值的平凡跟  如果是负值 返回NaN  </li>
<li>Math.log()  返回以e为底的自然数对数值  </li>
<li>Math.exp()  返回常数e的参数次方  </li>
<li>Math.round() 四舍五入  </li>
<li>Math.random() 返回0-1之间一个伪随机数，0&#x3D;&lt;n&lt;1</li>
</ul>
<h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><hr>
<p>** 方法  </p>
<blockquote>
<ul>
<li>console.time()&amp;&amp;console.timeEnd()  可以算出一个操作花费的准确事件</li>
</ul>
</blockquote>
<ul>
<li>console.info()  </li>
<li>console.warn()  </li>
<li>console.error()  </li>
<li>console.log(dir)</li>
</ul>
<h2 id="JS类型转换"><a href="#JS类型转换" class="headerlink" title="JS类型转换"></a>JS类型转换</h2><hr>
<blockquote>
<ul>
<li>typeof NaN &#x3D;&#x3D;&#x3D;&gt; number</li>
</ul>
</blockquote>
<ul>
<li>true &#x3D;&#x3D; 1 &#x3D;&#x3D;&#x3D;&#x3D;&gt; true  </li>
<li>99999999999999 &#x3D;&#x3D;&#x3D;&gt; 10000000000000  </li>
<li>0.5+0.1 &#x3D;&#x3D; 0.6 &#x3D;&#x3D;&gt; true  </li>
<li>Math.max() &#x3D;&#x3D;&#x3D;&gt;-Infinity   Math.min()  &#x3D;&#x3D;&#x3D;&gt; Infinity  </li>
<li>[]+[] &#x3D;&#x3D;&#x3D;&gt; “”  </li>
<li>[]+{} &#x3D;&#x3D;&#x3D;&gt;[object object]  </li>
<li>{}+[] &#x3D;&#x3D;&#x3D;&gt; 0  </li>
<li>true+true+true &#x3D;&#x3D;&#x3D;&gt; 3  </li>
<li>true-true &#x3D;&#x3D;&#x3D;&gt; 0  </li>
<li>[] &#x3D;&#x3D; 0 &#x3D;&gt;true  </li>
<li>(!+[]+[]+![]).length   &#x3D;&#x3D;&#x3D;&gt; 9</li>
</ul>
<hr>
<p>** 强弱类型  </p>
<blockquote>
<p>强类型的语言遇到函数参数和实际调用参数类型不符合会直接报错或编译失败<br>  而弱类型语言会实行<em>隐式</em>转换<br>  强：c，c++，java，c fuck，<br>  弱：php，asp，js，python<br>** 静态，动态类型<br>动态编程语言：再运行的时候可以改变其结构的语言，例如对象，函数，代码可以被引进 ，已有的函数可以被删除<br>  运行时才知道一个变量类型<br>  php，ruby，python 而c，c++，java不属于动态语言<br>  静态语言：编译的时候就知道变量类型 </p>
</blockquote>
<h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3><hr>
<p>** 在程序运行过程中，类型会被自动确定，可以使用同一个变量保存不同类型的数据<br>** 最新的ECMAScript标准定义了8中数据类型  </p>
<blockquote>
<ul>
<li>Boolean</li>
</ul>
</blockquote>
<ul>
<li>Number  </li>
<li>String  </li>
<li>Null  </li>
<li>Undefined  </li>
<li>Object   </li>
<li>BigInt  </li>
<li>Symbol<br>** 注意**：</li>
<li>+-infinity和NaN都是Number类型  </li>
<li>对象，数组，Data,正则都是Object  </li>
<li>typeof null &#x3D;&#x3D;&#x3D;‘object’  对线类型的标签是0，由于null代表<br>空指针，值为0X00 因此null的类型标签是0，所以返回object  <h3 id="JS类型转换-1"><a href="#JS类型转换-1" class="headerlink" title="JS类型转换"></a>JS类型转换</h3>　　**********<br>** js类型转换分为显示类型转换，隐式类型转换  <h4 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h4></li>
</ul>
<hr>
<p><strong>通过js提供的函数直接转换</strong>  </p>
<blockquote>
<ul>
<li>转换为Number: <strong>Number</strong>,<strong>parseFloat()</strong>,<strong>parseInt()</strong></li>
</ul>
</blockquote>
<ul>
<li>转换为String: <strong>String()</strong>,<strong>toString()</strong>  </li>
<li>转换为Boolean ： <strong>Boolean()</strong><br> <strong>js中对象到字符串的经过</strong> <blockquote>
<ul>
<li>如果对象有toString方法，则调用，若返回的是基本类型值，js转换为字符串，并返回</li>
</ul>
</blockquote>
</li>
<li>没有toString方法，且返回的不是基本数据类型。js调用valueOf方法  </li>
<li>都不行此时抛出 “类型错误异常”</li>
</ul>
<p> <strong>注意</strong>：undefined，null，false，+-0，NAN，“”，只有这些toBoolean()是false其余为true  </p>
<hr>
<p> <strong>toPrimitive</strong>将值转额外i原始值  </p>
<blockquote>
<p>toPrimitive(data.PreferredType) </p>
</blockquote>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><hr>
<p>js的隐式转换主要涉及 + 和  &#x3D;&#x3D;  </p>
<p>**[object object]  </p>
<blockquote>
<p>将对象数组调用了toString方法，转换为了字符串，注意避免使用+进行隐式转换  </p>
</blockquote>
<p>** x &#x3D;&#x3D; y  </p>
<blockquote>
<p>x,y为null，undefined两者中一个，返回true<br>  x,y为Number和String类型时，转换为Number类型比较<br>  有Boolean类型时，转换为Number类型比较<br>  一个Object 和一个String或Number比较，将Object进行原始转换<br>     [1]&#x3D;&gt;1  {}&#x3D;&gt;NaN  [1,2]&#x3D;&gt;NaN</p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>面试题</tag>
        <tag>Object</tag>
      </tags>
  </entry>
</search>
